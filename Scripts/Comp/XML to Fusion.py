# XML to Fusion 0.8

# Copyright (c)2015 Milos Labski

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

"""
Requirements:
-   Fusion 7.7 and above (not tested with older versions)
-   Python 2.7 and above

Notes:
-   supports FCP XML files up to version 5
-   imports sequences or bins from projects
-   compatible with xml files generated by Adobe Premiere, Apple Final Cut Pro and BMD Resolve
-   effects are not evaluated, list of effects applied on clip is saved in tool comments
-   transitions are handled as blend values on merge nodes

Known bugs and limitations
-   time remapping is not supported
-   once all composition windows in Fusion have been closed, the import does not work anymore, please restart Fusion and create new     composition window
-   using of non-ascii characters in filenames or directories may lead to unexpected results

Tips:
-   save your preferred saver settings as default before import
-   report bugs and improvement ideas here in forum
-   please attach xml files that do not work
"""

__Version__ = 0.8
__Author__="Milos L"
__name__ = 'XML to Fusion'

import logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

import sys
#logger.info(sys.version)
import os
import platform
import unicodedata
try:
    import urllib.parse as urlparser  # python3
except ImportError:
    try:
        import urlparse as urlparser  # python2
    except ImportError:
        print ("URL parser not found, script execution aborted")
        exit_message("URL parser not found\n-Script execution stopped")

import xml.etree.ElementTree as ET
from collections import OrderedDict, defaultdict, Counter

# Set of parameters for FCP XML Format up to ver. 5
# Structure of Clipitem, if value is a empty string, parameter will be generated by script
clipitem_dictionary = OrderedDict(
    (('Clip', 'file/pathurl'), ('Name', 'name'), ('GlobalIn', 'start'), ('GlobalOut', 'end'), ('ClipTimeStart', 'in'),
     ('ClipTimeEnd', 'out'), ('Timebase', 'file/timecode/rate/timebase'), ('SequenceStartFrame', 'file/timecode/frame'),
     ('Width', 'file/media/video/samplecharacteristics/width'),
     ('Height', 'file/media/video/samplecharacteristics/height'),
     ('ClipDuration', 'duration'), ('FileDuration', 'file/duration'), ('Comments', ''), ('Online', ''), ('SeqID', ''),
     ('TrackID', ''),
     ('ClipID', ''), ('UID', '')))
# tile colors:
colors = {'online':{'R' : 75/255, 'G' : 125/255, 'B' : 60/255}, 'offline':{'R' : 125/255, 'G' : 15/255, 'B' : 15/255},
		'animated':{'R' : 120/255, 'G' : 70/255, 'B' : 0	/255}, 'subsequence':{'R' : 65/255, 'G' : 100/255, 'B' : 160/255},
		'unknown':{'R' : 165/255, 'G' : 165/255, 'B' : 165/255}, 'black':{'R' : 5/255, 'G' : 5/255, 'B' : 5/255}}
# supported saver formats (Fusion 7, Windows)
saver_formats = OrderedDict(
    (('Cineon Files', '.cin'), ('FITS Files', '.fits'), ('Maya IFF Files', '.iff'), ('DPX Files', '.dpx'),
     ('SGI Files', '.sgi'), ('Radiance HDR Files', '.hdr'), ('OpenEXR Files', '.exr'), ('Rendition Files', '.6RN'),
     ('Alias PIX Files', '.als'), ('QuickTime Movies', '.mov'), ('Targa Files', '.tga'), ('Quantel VPB Files', '.vpb'),
     ('SoftImage PIC Files', '.si'), ('IFF Files', '.iff'), ('IPL Files', '.ipl'), ('YUV Files', '.yuv'),
     ('Stamp Files', '.FuStamp'), ('TIFF Files', '.tif'), ('JPEG Files', '.jpg'), ('SUN Raster Files', '.RAS'),
     ('DDS Files', '.dds'), ('Windows Bitmap Files', '.BMP'), ('Pandora YUV Files', '.piyuv10'),
     ('JPEG2000 Files', '.jp2'),
     ('PNG Files', '.png'), ('OMF Interchange Files', '.omf'), ('AVI Files', '.avi')))

transitem_dictionary = OrderedDict((('start', 'start'), ('end', 'end'), ('alignment', 'alignment'),
                                    ('effectid', 'effect/effectid')))  # transition data
meta_tc_fuse_table = (24, 25, 30, 48, 50, 60)
all_parsed_clipitems = []  # parsed clipitems as list
all_transitems = []  # parsed transition items as list
current_transition_index = 0  # current transition counter
clip_transitions = defaultdict(dict)  # holds transition values assigned to clipitems
clipitems_counter = defaultdict(
    dict)  # saves number of clipitems per sequence and track ( [seqid][trackid]=number of clipitems)
saved_file_par = defaultdict(dict)  # saved file-id linked parameters
item_uid = 0  # unique id counter for parsed items
seq_number = 0  # sequences counter
subseq_list = {}  # subsequences associated with clipitems through uid (for future use)

global last_bg_output, last_fg_output  # output of current tools
saver_paths_duplicates = {}  # for saver already existing in composition
global first_XPos, first_YPos  # start position of flow
xml_type = ""  # bin or seq
prj = {}  # fusion project parameters
xml = {}  # xml project parameters


# ---------------------------------------------- -------FUNCTIONS-------------------------------------------------------
# ____________________________________________________FLOW CREATION_____________________________________________________


# create loader or text+ node
def create_source_node(clipitem):
    global all_transitems
    global current_transition_index
    global clip_transitions
    logger.debug(clipitem)
    if par_value(clipitem, 'Online'):  # we create loaders only for online files
        mysource = comp.AddTool("Loader")
        mysource['Clip'][1] = (clipitem[par_pos('Clip')])

        # compute ClipTimeStart, ClipTimeEnd for clips with  framerate different from composition framerate

        # if frame rate of file is not corresponding with composition framerate, we need corrections on ClipTimeStart and ClipTimeEnd
        if par_value(clipitem, 'Timebase') != 0 and par_value(clipitem, 'Timebase') != xml["fps"]:
            fps_conv_rate = par_value(clipitem, 'Timebase') / xml["fps"]
            update_clipitems('UID', par_value(clipitem, 'UID'), 'ClipTimeStart', int(
                par_value(clipitem, 'ClipTimeStart') * fps_conv_rate))  # update value in the all_clipitems table
            update_clipitems('UID', par_value(clipitem, 'UID'), 'ClipTimeEnd', int(
                par_value(clipitem, 'ClipTimeEnd') * fps_conv_rate))  # update value in the all_clipitems table
        # set color
        mysource.TileColor = colors['online']
    else:
        mysource = comp.AddTool(
            "TextPlus")  # for clipitems without path and for offline clips we create Text+ nodes instead loaders
    # compute Global In/Out points. We follow "transition starting at cut" concept
    if par_value(clipitem,
                 'GlobalIn') == -1:  # we have transition on In, so it must be a transition item before this clipitem
        logger.debug("UID: ", par_value(clipitem, 'UID', 0), "in: \n", clipitem)
        # update value in the all_clipitems table with startpoint of current transition
        update_clipitems('UID', par_value(clipitem, 'UID'), 'GlobalIn', all_transitems[current_transition_index][0])
        # we save IN transition for later use
        clip_transitions['in'][par_value(clipitem, 'UID')] = all_transitems[current_transition_index]
        logger.info("all_transitems[current_transition_index]", all_transitems[current_transition_index])
        current_transition_index += 1
    # compute GlobalOut
    if par_value(clipitem, 'GlobalOut') == -1:  # we have transition on out
        logger.debug("UID: ", par_value(clipitem, 'UID'))
        update_clipitems('UID', par_value(clipitem, 'UID'), 'GlobalOut', all_transitems[current_transition_index][1])  # set Out value to endpoint of current transition
        next_gi = par_value_by_UID("GlobalIn", par_value(clipitem, 'UID') + 1)  # get the GlobalIn of the next Clipitem
        next_ti = par_value_by_UID("TrackID", par_value(clipitem, 'UID') + 1)  # get the TrackID of the next Clipitem
        if next_gi == -1 and par_value(clipitem, 'TrackID') == next_ti:  # next clipitem has transition on in and is in the same track

            pass  # to simulate cross dissolve effect, we won't create fade out if next clip has a fade in...
        else:
            clip_transitions['out'][par_value(clipitem, 'UID')] = all_transitems[
                current_transition_index]  # we save Out transition for animation
            current_transition_index += 1
    # set tool name
    mysource.SetAttrs({'TOOLS_Name': "_" + par_value(clipitem, 'Name')})
    # set GlobalIn/Out

    mysource['GlobalIn'][1] = par_value(clipitem, 'GlobalIn')
    if xml_type == "seq":
        mysource['GlobalOut'][1] = par_value(clipitem, 'GlobalOut')
    # and as last parameters ClipTimeStart/End (for online loaders only)
    if par_value(clipitem, 'Online'):
        mysource['ClipTimeStart'][1] = par_value(clipitem, 'ClipTimeStart')
        if xml_type == "seq":
            mysource['ClipTimeEnd'][1] = par_value(clipitem, 'ClipTimeEnd')
        # and one more time to be sure, that fusion has not changed our points ;)
        mysource['GlobalIn'][1] = par_value(clipitem, 'GlobalIn')
        if xml_type == "seq":
            mysource['GlobalOut'][1] = par_value(clipitem, 'GlobalOut')
        mysource['ClipTimeStart'][1] = par_value(clipitem, 'ClipTimeStart')
        if xml_type == "seq":
            mysource['ClipTimeEnd'][1] = par_value(clipitem, 'ClipTimeEnd')
        # and finaly clean hold frames produced in some cases by Fusion
        mysource['HoldFirstFrame'][1] = 0
        mysource['HoldLastFrame'][1] = 0
    else:
        if par_value(clipitem, 'Clip') == 0:  # generic items, e.g. adjustment layers, black clips, unknown file formats...
            mysource.Size = 0.04
            mysource.Style = "Regular"
            mysource.StyledText = par_value(clipitem, 'Name')
            mysource.TileColor = colors['unknown']
            # FCP "Slug" means black clip
            if par_value(clipitem, 'Name') == "Slug":
                mysource.Alpha = 1
                mysource.StyledText = ""
                mysource.TileColor = colors['unknown']
        else:  # offline clips
            text = "Offline Clip: " + str(par_value(clipitem, 'Name')) + "\n" + str(par_value(clipitem, 'Clip')) + "\n"
            if xml_type == "seq" or par_value(clipitem, 'ClipTimeStart') != 0:
                text += "Clip In: " + str(par_value(clipitem, 'ClipTimeStart'))
            if xml_type == "seq" or par_value(clipitem, 'ClipTimeEnd') != 0:
                text += ", Clip Out: " + str(par_value(clipitem, 'ClipTimeEnd'))
            if xml_type == "seq":
                text += ", Comp In: " + str(par_value(clipitem, 'GlobalIn'))
                text += ", Comp Out: " + str(par_value(clipitem, 'GlobalOut'))
                text += ", Track: " + str(par_value(clipitem, 'TrackID'))
            mysource.Style = "Regular"
            mysource.Size = 0.035
            mysource.HorizontalJustification = 0
            mysource.Center = [0.05, 0.1]  # bottom left
            mysource.StyledText = text
            mysource.TileColor = colors['offline']
    mysource.Comments = par_value(clipitem, 'Comments')
    logger.info("Created: ", clipitem)
    return mysource


def create_timespeed_node(clipitem):
    if par_value(clipitem, 'Clip') != 0 and par_value(clipitem, 'Timebase') != 'undefined' and par_value(clipitem, 'Timebase') != prj["fps"]:
        mytool = comp.AddTool("TimeSpeed")
        mytool.SetAttrs({'TOOLS_Name': "TimeSpeed_" + str(par_value(clipitem, 'TrackID')) + "_" + str(
            par_value(clipitem, 'ClipID'))})
        mytool.Speed = par_value(clipitem, 'Timebase') / prj["fps"]
        if not par_value(clipitem,
                         'Online'):  # we have replaced offline clips with Text+ nodes, so we don't need this Timespeed node now. However, we leave it in comp
            mytool.SetAttrs({"TOOLB_PassThrough": True})
        return mytool
    else:
        return False


def create_resize_node(clipitem):
    if (par_value(clipitem, 'Width') != '' and par_value(clipitem, 'Width') != prj["width"]) or (
            par_value(clipitem, 'Height') != '' and par_value(clipitem, 'Height') != prj["height"]):
        mytool = comp.AddTool("BetterResize")
        mytool.SetAttrs(
            {'TOOLS_Name': "Resize_" + str(par_value(clipitem, 'TrackID')) + "_" + str(par_value(clipitem, 'ClipID'))})
        if not par_value(clipitem,
                         'Online'):  # we have replaced offline clips with Text+ nodes, so we don't need this resize node now. However, We leave it in comp
            mytool.SetAttrs({"TOOLB_PassThrough": True})
        return mytool
    else:
        return False


# creates Merge node
def create_merge_node(clipitem):
    global last_bg_output, last_fg_output
    global current_transition
    global xml_type
    mixer = comp.AddTool('Merge')
    # add animation
    if par_value(clipitem, 'UID') in clip_transitions["in"] or par_value(clipitem, 'UID') in clip_transitions["out"]:
        logger.info("---animate mixer ---")
        if mixer.AddModifier("Blend", "BezierSpline"):  # simple animation
            if par_value(clipitem, 'UID') in clip_transitions["in"]:  # we have in transition on this clipitem, fade in
                current_transition = clip_transitions["in"][par_value(clipitem, 'UID')]
                mixer.Blend[par_value(current_transition, 'start', True)] = 0
                mixer.Blend[par_value(current_transition, 'end', True)] = 1
            if par_value(clipitem, 'UID') in clip_transitions["out"]:#we have out transition on this clipitem, fade out
                current_transition = clip_transitions["out"][par_value(clipitem, 'UID')]
                mixer.Blend[par_value(current_transition, 'start', True)] = 1
                mixer.Blend[par_value(current_transition, 'end', True)] = 0
            logger.info("animated out")
            mixer.TileColor = colors['animated']
            # delete keyframe created by Fusion at current time
            if comp.CurrentTime != par_value(current_transition, 'start',
                                                    True) or comp.CurrentTime != par_value(current_transition,
                                                                                                  'end', True):
                mixer.Blend[comp.CurrentTime] = None
            # add some information about transition to comments
            mixer.Comments = str(par_value(current_transition, 'alignment', True)) + ", " + str(
                par_value(current_transition, 'effectid', True))
    # add simple fade out for all clips without transition on last frame
    else:
        if mixer.AddModifier("Blend", "BezierSpline"):
            mixer.Blend[par_value(clipitem, 'GlobalOut') - 1] = 1
            mixer.Blend[par_value(clipitem, 'GlobalOut')] = 0
            if comp.CurrentTime != par_value(clipitem, 'GlobalOut') - 1 or comp.CurrentTime != par_value(
                                                                                                clipitem, 'GlobalOut'):
                mixer.Blend[comp.CurrentTime] = None
    # set remaining merge parameters
    mixer.SetAttrs({'TOOLS_Name': "_" + str(int(par_value(clipitem, 'GlobalIn'))) + "_" + str(
        int(par_value(clipitem, 'GlobalOut')))
                                  + "_T" + str(par_value(clipitem, 'TrackID')) + "_ID" + str(
        par_value(clipitem, 'ClipID'))})
    return mixer



#returns path, filename and extension for saver
def unique_saver_name(clipitem, ctype):
    mpath = ""  # base path to savers
    global saver_paths_duplicates
    saver_fname = ""
    # file name
    if ctype == "clipitem":
        if par_value(clipitem, "Name") != 0:
            saver_fname = par_value(clipitem, "Name")
        else:
            saver_fname =  xml["name"]
    elif ctype == "track":
      saver_fname = xml["name"] + "_Track_" + str(par_value(clipitem, "TrackID"))
    elif ctype == "seq":
        saver_fname = xml["name"] + "_SEQ_"

    # extension
    ext = list(saver_formats.values())[int(dialog4_s["saver_format"])]

    # if saver is image sequence, we add "_" to avoid issues with names ending with a number
    if ext != ".mov" and ext != ".avi":
        saver_fname += "_"

    # path
    if dialog4_s["create_subdir"] == 1:
        mpath = os.path.join(dialog4_s["saver_maindir"], xml["name"])  # add main subdirectory
    else:
        mpath = dialog4_s["saver_maindir"]
    if ext != ".mov" and ext != ".avi":
        mpath = os.path.join(mpath, saver_fname)  # subdirs for all image sequences

    # is saver path unique in composition?
    s_paths = (comp.GetToolList(False, "Saver"))
    if len(s_paths) > 0:
        for s_path in list(s_paths.values()):
            s_path = s_path.GetAttrs('TOOLST_Clip_Name')[1]
            # is path for our new saver already used?
            if s_path == os.path.join(mpath, saver_fname + ext):
                # initiate duplicate counter if needed
                logger.info("Saver path already exists: ", s_path)
                try:
                    if saver_paths_duplicates[s_path]:
                        pass
                except KeyError:
                    saver_paths_duplicates[s_path] = 0
                    logger.info("Duplicates counter for ", s_path, "set to 0")
                saver_paths_duplicates[s_path] += 1
                # we give for each next occurrence of this path a number-suffix
                saver_fname += "." + str(saver_paths_duplicates[s_path]).zfill(3)
                logger.info("Saver path not unique, added suffix", str(saver_paths_duplicates[s_path]).zfill(3))
            logger.info(s_path,os.path.join(mpath, saver_fname + ext) )
    return os.path.join(mpath, saver_fname + ext)

def create_timecode_node(clipitem):
    global last_bg_output, last_fg_output
    tc_node_fps = 0
    try:
        orig_timebase = int(par_value(clipitem, 'Timebase'))
    except:
        return False
    if orig_timebase == 0:
        return False
    fps_conv_rate = orig_timebase / prj["fps"]
    try:
        tc_node_fps = meta_tc_fuse_table.index(prj["fps"])
    except ValueError:
        logger.info("Frame rate is not supported. MetadataTC node can't be created.")
    if tc_node_fps != 0:
        mytc_node=comp.AddTool('Fuse.SetMetaDataTC')
        framecount = par_value(clipitem, "SequenceStartFrame") +  par_value(clipitem, "ClipTimeStart") -  (par_value(clipitem, "GlobalIn") * fps_conv_rate)
        hours = framecount / (3600 * orig_timebase)
        minutes = framecount / (60 * orig_timebase) % 60
        seconds =  framecount / orig_timebase % 60
        frames = framecount % orig_timebase
        mytc_node.TCHours = int(hours)
        mytc_node.TCMinutes = int(minutes)
        mytc_node.TCSeconds = int(seconds)
        mytc_node.TCFrames = int(frames)
        mytc_node.FPS = tc_node_fps
        mytc_node.Input = last_fg_output
        last_fg_output = mytc_node.Output
        return True
    else:
        return False

def create_saver_node(clipitem, ctype):
    """
    creates Saver Node depending on settings in dialog4 and dialog3
    :param ctype:  valid options are "clipitem", "track", "seq"
    """
    global last_bg_output, last_fg_output
    if dialog3_s["saver_creation"] == 1:
        saver_fname = unique_saver_name(clipitem, ctype )
        # clipitem saver
        if ctype == "clipitem" and dialog4_s["create_cl_saver"] != 0: # some clipitem-saver will be created
            if dialog4_s["create_cl_saver"] == 1 or (
                    dialog4_s["create_cl_saver"] == 2 and par_value(clipitem, "Clip") != 0) or (
                    dialog4_s["create_cl_saver"] == 3 and par_value(clipitem, "Online")):
                # creation
                mytool = comp.AddTool('Saver', comp.XPos, comp.YPos, True)
                mytool.Input = last_fg_output
                # last_fg_output = mytool.Output # connect saver to the next tool?
                mytool.Clip = saver_fname
                #set parameters
                mytool.GlobalIn = par_value(clipitem, "GlobalIn")
                mytool.GlobalOut = par_value(clipitem, "GlobalOut")
                mytool.CreateDir = 1
        # track saver
        elif ctype == "track" and dialog4_s["create_track_saver"] == 1:
            comp.XPos = first_XPos + par_value(clipitem, "ClipID") + 1
            mytool = comp.AddTool('Saver', comp.XPos, comp.YPos, True)
            mytool.Input = last_bg_output
            # last_fg_output = mytool.Output
            mytool.Clip = saver_fname
            mytool.CreateDir = 1
        # sequence saver
        elif ctype == "seq" and xml_type == "seq" and dialog4_s["create_seq_saver"] == 1:
            comp.XPos += 2
            mytool = comp.AddTool('Saver', comp.XPos, comp.YPos, True)
            mytool.Input = last_bg_output
            # last_fg_output = mytool.Output
            mytool.Clip = saver_fname
            mytool.CreateDir = 1
        else:
            return False
    else:
        return False


# builds flow - adds source/creator tools, conforming tools
def create_flow(items_list):
    logger.info("---create flow---")
    global last_bg_output, last_fg_output
    global first_XPos, first_YPos
    global subseq_list
    height_counter = 0

    # creation for merge/dissolve flow
    for clipitem in items_list:
        if par_value(clipitem, 'SeqID') == 0:  # main sequence only
            item_id = par_value(clipitem, 'ClipID')
            item_track = par_value(clipitem, 'TrackID')
            item_seqid = par_value(clipitem, 'SeqID')
            print("Creating flow column ", item_track, "-" , item_id)
            if item_id == 1:  # for new track
                track_height, offset_y = get_nodes_positions(item_track,
                                                             item_seqid)  # get track height and tools positions for current track
                height_counter = height_counter + track_height
                comp.XPos = first_XPos  # go to line begin
                # create Note node, marking begin of track
                comp.YPos = first_YPos - height_counter + offset_y["creator"]
                track_note = comp.AddTool("Note")
                if xml_type == "seq":
                    track_note.SetAttrs({'TOOLS_Name': "Track" + str(item_track)})
                track_note.Comments = str(clipitems_counter[0][item_track]) + " clip(s)"

            if par_value(clipitem, 'UID') in subseq_list:
                # subgroup = comp.AddTool("GroupOperator")
                # subgroup.TileColor = color['subsequence']
                logger.info("is sequence")

            # create loader/source node
            comp.YPos = first_YPos - height_counter + offset_y["creator"]
            comp.XPos = first_XPos + item_id
            mysource = create_source_node(clipitem)
            last_fg_output = mysource.output

            # add TimeSpeed Node for clips with different framerate
            comp.YPos = first_YPos - height_counter + offset_y["timespeed"]
            mytool = create_timespeed_node(clipitem)
            if mytool:
                mytool.Input = last_fg_output
                last_fg_output = mytool.output

            # create TC Metadata Node, if applicable
            if dialog3_s["create_timecode"] == 1:
                comp.YPos = first_YPos - height_counter + offset_y["tc"]
                create_timecode_node(clipitem)

            # add Resize Node for clips with different dimensions
            comp.YPos = first_YPos - height_counter + offset_y["resize"]
            mytool = create_resize_node(clipitem)
            if mytool:
                mytool.Input = last_fg_output
                last_fg_output = mytool.output

            # create saver after conforming tools
            comp.YPos = first_YPos - height_counter + offset_y["saver"]
            create_saver_node(clipitem, "clipitem")

            # create merge node
            if xml_type == "seq":
                comp.YPos = first_YPos - height_counter + offset_y["merge"]
                mixer = create_merge_node(clipitem)
                if mixer:
                    mixer.Background = last_bg_output
                    mixer.Foreground = last_fg_output
                    last_bg_output = mixer.output

            # on last clipitem in row
            if not par_value_by_UID("TrackID", par_value(clipitem, 'UID') + 1):
                if par_value(clipitem, "TrackID") != par_value_by_UID("TrackID", par_value(clipitem, 'UID') + 1):
                    # create track saver if selected in dialog
                    create_saver_node(clipitem, "track")
                # add one empty row
                # height_counter +=1


def get_nodes_positions(track_num, seq_num):
    """Returns track height and Y-Positions of tools"""
    global dialog3_s, dialog4_s
    global seq
    global all_parsed_clipitems
    track_height = 0
    ts = 0  # TimeSpeed
    rs = 0  # Resize
    if dialog3_s["create_timecode"] == 1:  # Timecode
        tc = 1
    else:
        tc = 0
    if int(dialog3_s["saver_creation"]) == 0: # Saver
        sv = 0
    else:
        sv = 1
    cspace = int(dialog3_s["add_space"]) #space for custom tool before saver
    for clipitem in all_parsed_clipitems:
        if par_value(clipitem, "SeqID") == seq_num and par_value(clipitem, "TrackID") == track_num:
            if ts == 0 and par_value(clipitem, 'Clip') != 0 and par_value(clipitem, 'Timebase') != 0 and par_value(
                    clipitem, 'Timebase') != prj["fps"]:
                ts = 1
            if rs == 0 and (par_value(clipitem, 'Width') != 0 and par_value(clipitem, 'Width') != prj["width"]) or (
                    par_value(clipitem, 'Height') != 0 and par_value(clipitem, 'Height') != prj["height"]):
                rs = 1
    # calculate positions
    pos_Y = {}
    pos_Y["creator"] = 0
    pos_Y["timespeed"] = 1
    pos_Y["tc"] = ts + 1
    pos_Y["resize"] = ts + tc + 1
    pos_Y["saver"] = ts + tc + rs + cspace + 1
    pos_Y["merge"] = ts + tc + rs + cspace + sv + 1

    track_height = pos_Y["merge"] + 1
    logger.info("Track height: ", track_height)
    return track_height, pos_Y


# ---------------------------------------------- -------FUNCTIONS-------------------------------------------------------------
# ____________________________________________________XML PARSING____________________________________________________________________

# adds clipitems and transitems from xml sequence to global all_clipitems and all_transitems lists
def parse_sequence(sequence):
    logger.info("--- parse_sequence ---")
    global seq_number, subseq_list, clipitems_counter, all_transitems
    track_trans = []  # temporary transition container
    transitem_number = 0  # transitions counter for transition id
    track_number = 0
    seq_tracks = sequence.findall("./media/video/track")
    print("seq tracks:", seq_tracks)
    print('Number of tracks in sequence: ', len(seq_tracks))
    for track in seq_tracks:
        if is_video_item(track):
            track_number += 1
            clipitems = track.findall("./clipitem")  # get first level clipitems only
            print("Track", track_number, "contains", len(clipitems), "clipitem(s)")
            parse_clipitems(clipitems, seq_number, track_number)
            # find and save transitions
            if track.find(".//transitionitem"):
                transitems = track.findall("./transitionitem")
                print("Track", track_number, "contains", len(transitems), "transition(s)")
                for transitem in transitems:
                    transitem_number += 1
                    for par_req in list(transitem_dictionary.values()):
                        try:
                            track_trans.append(try_float(transitem.find(".//" + par_req).text))
                            logger.debug(par_req + transitem.find(".//"+par_req).text)
                        except:
                            logger.debug("Transition value for ", par_req, " not found.")
                            track_trans.append(None)
                    track_trans.append(track_number)  # add track id...
                    track_trans.append(transitem_number)  # ...transition id
                    all_transitems.append(
                        track_trans[:])  # append completed transitem list to the global transition list
                    del track_trans[:]
        else:
            logger.info("Skipping non-video item...")
    logger.info("Transition items in this sequence: ", all_transitems)
    seq_number += 1


# get clips from bin and sent to parse_clipitems function
# returns true if any clips found, false if not
def parse_bin(bin):
    logger.info("--- parse bin ---")
    if bin == "- Main":
        try:
            clipitems = main_project.findall("./children/clip/media/video/track/clipitem")
        except:
            clipitems = None
            logger.info("No clips found in bin")
    else:
        try:
            clipitems = bin.findall("./children/clip/media/video/track/clipitem")  # get first level clipitems
        except:
            clipitems = None
            logger.info("No clips found in bin")
    if clipitems != None:
        logger.info("Number of clipitems in bin:", len(clipitems))
        parse_clipitems(clipitems)
        return True
    else:
        return False


# gets file-id parameter from clipitem
def get_file_id(clipitem):
    try:
        current_file_id = clipitem.find("./file/[@id]").get('id')
        logger.info("file id: ", current_file_id)
        return current_file_id
    except:
        logger.info("File id not found")
        return False


# gets (video)clipitems in main sequence and saves file-based parameters in saved_file_par
def save_file_links():
    logger.info("--- save_file_links ---")
    global saved_file_par, xml_type
    clipitems = root.findall(".//clipitem")  # in whole xml file and on all levels
    for clipitem in clipitems:
        if is_video_item(clipitem):
            current_file_id = get_file_id(clipitem)
            for par_req in list(clipitem_dictionary.items()):
                if clipitem.find("./file") and "file/" in par_req[1]:  # has file subtree and only file related parameters
                    logger.info("file id / par req: ", current_file_id, par_req)
                    if par_req[0] == 'Clip':
                        try:
                            saved_file_par[current_file_id][par_req[0]] = adapt_path(clipitem.findtext("./" + par_req[1]))
                        except:
                            logger.info("Value for -Clip- not found (message from save_file_links)")
                            continue
                    else:
                        try:
                            saved_file_par[current_file_id][par_req[0]] = try_float(
                                clipitem.find("./" + par_req[1]).text)
                        except:
                            logger.info("Value for ", par_req[0], " not found(message from save_file_links)")
                            continue
                    logger.info("saved(save_file_links)", par_req[0], clipitem.find("./" + par_req[1]).text)
                    continue
    if len(saved_file_par) > 0:
        return saved_file_par
    else:
        return False


# saves clipitems formatted as defined in "clipitem_dictionary" to global "all_parsed_clipitems" list
def parse_clipitems(clipitems, seq_number=0, track_number=0):
    logger.info("--- parse_clipitems ---")
    global all_parsed_clipitems
    global item_uid
    global saved_file_par
    global xml_type
    val = None
    clips = None
    clipitem_number = 0
    for clipitem in clipitems:
        clipitem_number += 1
        myclip = []
        current_file_id = get_file_id(clipitem)
        for par_req in list(clipitem_dictionary.items()):  # read clipitem parameters from xml and save to our "all_parsed_clipitems" list
            logger.info("saved_file_par[current_file_id]", saved_file_par[current_file_id])
            if current_file_id in saved_file_par and par_req[0] in saved_file_par[
                current_file_id]:  # file-level parameters should be found in saved_file_par
                logger.info(par_req[0], saved_file_par[current_file_id][par_req[0]])
                myclip.append(saved_file_par[current_file_id][par_req[0]])
                logger.info("parameter from saved file id", par_req[0])
                continue
            elif par_req[1] != "":  # clipitem-level parameters group (Name, In, Out, Global In, Global Out)
                try:
                    myclip.append(try_float(clipitem.find("./" + par_req[1]).text))
                    logger.info(clipitem.find("./" + par_req[1]).text, "from clipitem-level appended to", par_req[0])
                    continue # next parameter
                except:
                    logger.info("Value for clipitem parameter", par_req[0], " not found, will try clip parameters")
                if xml_type == "seq":
                    myclip.append(0)  # this is probably not ok in seqeunce-based xml...
                    logger.info("! Value for clipitem parameter", par_req[0], " not found, appended '0'")
                # usable only in "bin" mode - where we have clip level in bin...
                else:
                    try:
                        clips = main_element.findall("./children/clip")
                    except:
                        clips = None
                        logger.info("No clips in bin found or no bin exists, appended 0")
                        myclip.append(0)
                        continue
                    if clips != None:
                        for clip in clips:  # compare master id's from clips with current clipitem's master-id
                            if clip.findtext("./masterclipid") == clipitem.findtext("./masterclipid"):
                                logger.info("clipitem found")
                                try:
                                    myclip.append(try_float(clip.find("./" + par_req[1]).text))
                                    logger.info(clip.find("./" + par_req[1]).text, "from clip parameters appended to",
                                          par_req[0])
                                except:
                                    myclip.append(
                                        "undefined")  # in bin mode is this ok, we should know if value is 0 or not assigned
                                    logger.info("Value for clip parameter", par_req[0], " not found, appended 'undefined'")
                                break
                    else:  # no clips found
                        myclip.append(0)
                        logger.info("No clips in bin, appended 0")

        # if we found a subsequence
        if clipitem.find("./sequence"):
            subseq_list[item_uid] = clipitem.find("./sequence")
            logger.info("Nested clip found")
        # try to get list of effects on clipitem
        effects_list = ""
        try:
            effects = clipitem.findall(".//effectid")
            if effects:
                logger.info("Effects found")
                for effect in effects:
                    effects_list += effect.text + "\n"
            else:
                logger.info("No effects found")
        except:
            pass
        # before making any changes in this code, compare with clipitem_dictionary!!!
        myclip.append(effects_list) # effects found on clipitem
        myclip.append(False)  # online flag, check for real values later, after relink dialog
        myclip.append(seq_number)  # add SeqID
        myclip.append(track_number)  # ... TrackID...
        myclip.append(clipitem_number)  # ClipID in track
        myclip.append(item_uid)  # and UID
        item_uid += 1
        print("Parsed clip: ", myclip)
        all_parsed_clipitems.append(myclip[:])  # append completed clipitem to the list
        del myclip[:]
    clipitems_counter[seq_number][track_number] = clipitem_number  # holds number of clipitems per sequence and track
    # we should make "Name" values more script-friendly (remove extension, images-numbering, duplicate names)
    return (all_parsed_clipitems)


#removes file extension and fcp xml suffix for numbered Image sequences, make names unique (adds "_xy"-suffix)
def clean_clipitem_names():
    logger.info("--- clean_clipitem_names---")
    mylist = {}
    for clipitem in all_parsed_clipitems:
        # get name from numbered image sequences (with [xxx-yyy] suffix)
        if split_image_sequence(par_value(clipitem, "Name")):
            fname = split_image_sequence(par_value(clipitem, "Name"))['name']
            update_clipitems("UID", par_value(clipitem,"UID"),"Name", fname)
        else:
            # remove extension
            fname = (os.path.splitext((os.path.split(par_value(clipitem, "Name")))[1]))[0]
            update_clipitems("UID", par_value(clipitem,"UID"),"Name", fname)
        mylist[par_value(clipitem,"UID")] = fname
    logger.info(Counter(list(mylist.values())))
    # search for duplicates, add suffix
    for uid, fname in list(mylist.items()):
        number_of_duplicates = Counter(list(mylist.values()))[fname]
        if number_of_duplicates > 1:
            counter = 0
            for clipitem in all_parsed_clipitems:
                if par_value(clipitem,"Name")== fname:
                    counter += 1
                    update_clipitems("UID", par_value(clipitem,"UID"), "Name", fname + "_" + str(counter).zfill(2))



# path operations depending on platform
def adapt_path(value):  # works in Windows for mapped drives and unc paths  On Mac?
    if platform.system() == 'Windows':
        value = value.replace('file://localhost/', '')
        value = value.replace('file:', '')
        value = urlparser.unquote(value)
    # par_value = os.path.abspath(par_value)
    return value

# returns dictionary containing start frame, end frame, clipitem name, or False if name is not numbered image sequence
def split_image_sequence(name):
    ims = {}
    if "[" in name and "]" in name and "-" in name:
        i_end = name.rfind("]") - 1 # position of last digit
        i_start = name.rfind("[") + 1 # position of first digit
        i_sep = name.rfind("-")
        if i_end > i_start and i_sep < i_end and i_sep > i_start and name[i_end+2] == ".":
            logger.info(name[i_start],name[i_end],name[i_sep] )
            if name[i_start].isdigit() and name[i_end].isdigit():
                ims['start'] = name[i_start:i_sep]
                ims['end'] = name[i_sep+1:i_end+1]
                ims['name'] = name[0:i_start-1]
                logger.info (ims['name'], ims['start'], ims['end'])
            else:
                return False
        else:
            return False
    else:
        return False
    for n in ims['start']:
        if not n.isdigit():
            return False
    for n in ims['end']:
        if not n.isdigit():
            return False
    return ims


# in bin mode, overrides or sets undefined In and Out points to default values
# if all is True, overrides also defined points
def rewrite_bin_points(all=False):
    update_clipitems("GlobalIn", None, "GlobalIn", comp.GetAttrs("COMPN_GlobalStart"))
    if all:
        # overwrite all points
        update_clipitems("ClipTimeStart", None, "ClipTimeStart", 0)
        update_clipitems_copy("ClipTimeEnd", "FileDuration", False)
    else:
        # overwrite undefined points only
        update_clipitems("ClipTimeStart", "undefined", "ClipTimeStart", 0)
        update_clipitems_copy("ClipTimeEnd", "FileDuration", "undefined")


#returns formatted list of elements in project - or list element and his type with index 'search'
def projects_selection_list(elements, search=-1):
    sel_list = []
    counter = 0
    logger.debug(elements)
    for element in list(elements.itm()):
        if counter == search:
            return element[1]["Bin"], "bin"
        else:
            sel_list.append(element[0] + " - " + str(
                len(element[1]["Clips"])) + " Clips\n")  # add bin name and number of clips in selection list
        counter += 1
        for val in list(element[1]["Sequences"].itm()):  # add sequence names in selection list
            if counter == search:
                return val[1], "seq"
            else:
                sel_list.append("   " + val[0] + "*\n")  # seq name
            counter += 1
    return sel_list


# returns True if found and saved sequence, False if not
def get_sequence(sequence, elements, binname):
    linked_seq = None
    seqname = None
    try:
        seqname = sequence.find("./name").text # if we have full sequence definition, we should have a name ...
        logger.info ("Seq:", seqname)
    except:
        seqname = None
    if seqname is not None: # regular sequence found
        elements[binname]["Sequences"].update({seqname: sequence}) # we save this sequence and return True
        return True
    else:
        try:
            seq_id = sequence.find("./[@id]").get('id')
            logger.info(seq_id)
        except:
            seq_id = None
            logger.info("No sequence id found")
            return False
    if seq_id is not None:
        try:
            linked_seq = main_project.find(".//name/..[@id='" + str(seq_id) + "']")
            logger.info ("Linked sequence found", linked_seq)
        except:
            linked_seq = None
            logger.info ("Linked sequence not found")
            return False
    if linked_seq is not None:
        try:
            seqname = linked_seq.find("./name").text
        except:
            seqname = "Undefined"
        elements[binname]["Sequences"].update({seqname: linked_seq})# we save this sequence and return True
        return True
    else:
        return False



# returns a list of elements in project based xml
def find_project_elements():
    elements = {}
    elements["- Main"] = {}
    elements["- Main"]["Sequences"] = {}
    elements["- Main"]["Clips"] = {}

    # parse project-level sequences
    try:
        root_seqs = main_project.findall("./children/sequence")  # get main sequences from project
    except:
        root_seqs = None
        logger.info("No sequences found on project level")
    if root_seqs is not None:
        for seqs in root_seqs:
            get_sequence(seqs, elements, "- Main")
    # search for clips on project-level
    try:
        root_clips = main_project.findall("./children/clip")  # get clips in project root
    except:
        root_clips = None
        logger.info("No clips found in bin")
    if root_clips is not None:
        elements["- Main"]["Clips"] = root_clips
        elements["- Main"]["Bin"] = "- Main"
    # parse bins
    # find bins in project
    try:
        bins = main_project.findall(".//children/bin")  # get all bins
    except:
        bins = None
        logger.info("No bins in project")
    if bins is not None:
        logger.info("Number of bins in project:", len(bins))
        for subbin in bins:
            try:
                binname = subbin.find("./name").text
                logger.debug(binname)
            except:
                binname = "unknown"
                logger.debug(binname)
            elements[binname] = {}
            elements[binname]["Bin"] = subbin
            elements[binname]["Sequences"] = {}
            try:
                bin_seqs = subbin.findall("./children/sequence")  # get main sequences from bin
            except:
                bin_seqs = None
                logger.info("No sequences found in bin")

            # parse bin sequences
            if bin_seqs is not None:
                logger.debug(bin_seqs)
                for seqs in bin_seqs:
                    get_sequence(seqs, elements, binname)

            # search for clips in bins
            elements[binname]["Clips"] = {}
            try:
                bin_clips = subbin.findall("./children/clip")  # get clips in bin
            except:
                bin_clips = None
                logger.info("No clips found in bin")
            if bin_clips is not None:
                elements[binname]["Clips"] = bin_clips

    if len(elements) > 0:
        return elements
    else:
        return False


# ---------------------------------------------- -------FUNCTIONS-------------------------------------------------------
# ____________________________________________________  UTILITIES_______________________________________________________

	
# converts string to float if possible
def try_float(string):
    try:
        string = float(string)
    except:
        pass
    return string


# returns value of clipitem parameter, based on parameter name
def par_value(clipitem, par, trans=0):
    logger.debug("---par_value ---", clipitem, par, par_pos(par))
    try:
        value = clipitem[par_pos(par, trans)]
    except:
        logger.info('Value for ', par, ' not found')
        return False
    return value


# returns value of parameter par, based on UID
def par_value_by_UID(par, UID):
    global all_parsed_clipitems
    for clipitem in all_parsed_clipitems:
        if par_value(clipitem, "UID") == UID:
            logger.info("Value by UID for", par, "=", par_value(clipitem,par))
            return par_value(clipitem, par)
    logger.info("Value by UID for", par, "not found")
    return False


# returns position of clipitem parameter in the parameter list, based on parameter name
def par_pos(par, trans=0):
    if trans == 1:
        try:
            pos = list(transitem_dictionary.keys()).index(par)
            logger.debug('Parameter position found; ', pos)
        except:
            logger.info('Parameter position ', par, ' unknown')
            return False
    else:
        try:
            pos = list(clipitem_dictionary.keys()).index(par)
            logger.debug('Parameter position found: ', pos)
        except:
            logger.info('Parameter position ', par, ' unknown')
            return False

    return pos


# changes value for "destination" parameter to "value" in all clipitems where "selector"=="condition" (or in all clipitems, if "condition" is None)
def update_clipitems(selector, condition, destination, value):
    global all_parsed_clipitems
    counter = 0
    for clipitem in all_parsed_clipitems:
        if condition is not None:
            if par_value(clipitem, selector) == condition:
                clipitem[par_pos(destination)] = value
                counter += 1
        else:
            clipitem[par_pos(destination)] = value
            counter += 1
    logger.info("updated ", destination, "in ", counter, "items ", "to ", value)


# copies value of "destination" parameter to value of "source"  in all clipitems where "source"=="condition" (or in all clipitems, if "condition" is None)
def update_clipitems_copy(source, destination, condition=None):
    global all_parsed_clipitems
    counter = 0
    for clipitem in all_parsed_clipitems:
        if condition is not None and par_value(clipitem, source) == condition:
            clipitem[par_pos(source)] = clipitem[par_pos(destination)]
            counter += 1
        elif condition is None: # without condition we update all clipitems
            clipitem[par_pos(destination)] = clipitem[par_pos(source)]
            counter += 1

    logger.info("updated ", destination, "in ", counter, "items")


#returns formatted list of missing files
def create_path_list(off_list):
    ret = ""
    for item in off_list:
        ret += item + "\n"
    return ret

#returns True for video track, False for other tracks
def is_video_item(item):
    logger.info("--- is_video_item ---")
    try:
        flag1 = item.find(".//sourcetrack//mediatype").text
    except:
        flag1 = ""
    if (item.find(".//video") and flag1 != "audio") or item.find("./clipitem"):
        print("is_video_item returns True")
        return True
    else:
        print("is_video_item returns False")
        return False


# gets known load extensions as a flat list
def get_load_formats():
    ret = []
    regs = fusion.GetRegList("CT_ImageFormat")
    for thing in list(regs.values()):
        try:
            attrs = fusion.GetRegAttrs(thing.ID)
            logger.debug(attrs)
            if not attrs.get('REGB_MediaFormat_CanLoad', False):
                continue
            else:
                ext = list(attrs['REGST_MediaFormat_Extension'].values())
                for iext in ext:
                    ret.append(iext)
                continue
        except:
            continue
    return ret

# converts timecode to frames
def timecode_to_frames(timecode, framerate):
    try:
        return sum(f * int(t) for f,t in zip((3600*framerate, 60*framerate, framerate, 1), timecode.split(':')))
    except:
        print("Timecode not found")
        return 0


# True if extension in list of loadable formats, False if not
def is_loadable(path):
    try:
        ext = os.path.splitext(path)[1].lower()
    except:
        return False
    if ext in load_formats:
        return True
    else:
        return False

def get_max_out(maxout):
    for clipitem in all_parsed_clipitems:  # check clipitem's out points for global comp length...
        fps_conv_rate = par_value(clipitem, 'Timebase') / xml["fps"]
        if int(par_value(clipitem, "GlobalOut") * fps_conv_rate) > maxout:
                if int(par_value(clipitem, "GlobalOut") * fps_conv_rate) > maxout:
                    maxout = int(par_value(clipitem, "GlobalOut") * fps_conv_rate)
    if len(all_transitems) > 0:  # ... and transitions out points
        for transitem in all_transitems:
            if int(transitem[1] * fps_conv_rate) > maxout:
                if int(transitem[1] * fps_conv_rate) > maxout:
                    maxout = int(transitem[1])
    return maxout


# message box and exit
def exit_message(text):
    ex_dialog = comp.AskUser("XML Importer Message",
                               {1: {1: "Note", 2: "Text", "Readonly": True, "Wrap": True, "Lines": 3, "Name": "",
                                    "Default": text}})
    sys.exit(0)


def strip_name(filename):
	validFilenameChars = "-_.() %s%s" % (string.ascii_letters, string.digits)
	cleanedFilename = unicodedata.normalize('NFKD', filename).encode('ASCII', 'ignore')
	return ''.join(c for c in cleanedFilename if c in validFilenameChars)
	
	
#supported extensions for load as flat list
load_formats = get_load_formats()

# ------------------------------------------ START --------------------------------------------------------------------
# ----------------------------------------- XML FILE SELECTION DIALOG--------------------------------------------------
# _____________________________________________________________________________________________________________________

dialog = {}
fileselection = ""
while fileselection == "":
    d = {}
    d[1] = {1: "File", 2: "FileBrowse", "Name": "Select FCP XML file for import", "Default": ''}
    d[2] = {1: "do_relink", 2: "Multibutton", "Name": "Force relink:", "Options": ["No", "Yes"], "Default": 0}
    #d[3] = {1: "Message:", 2: "Text", "Name": "", "ReadOnly": True, "Lines": 6, "Wrap": True,
    #        "Default": "- No - \nsearch for files at their original locations\n- Yes - \nyou have to set the new location of all clips in the next step"}
    dialog = comp.AskUser("XML Importer - File selection", d)
    if dialog is None:
        print("File selection dialog canceled.")
        exit_message("XML file selection canceled\n- script execution stopped")
    elif dialog['File'] != "":
        break



# ----------------------------------------------MAIN SEQUENCE SETTINGS FROM FILE -------------------------------------
# ____________________________________________________________________________________________________________________

# read xml file
try:
    tree = ET.parse(dialog['File'])
except:
    print("Error while reading XML File. Script execution stopped.")
    exit_message("Error while reading XML File\n- script execution stopped")
root = tree.getroot()

# determine xml type and usability of data

# is this a sequence based xml?
try:
    main_element = root.find("./sequence")
    logger.info("Main sequence: ", main_element)
except:
    main_element = None
    print("No sequence found in xml root")
if main_element is not None:
    xml_type = "seq"
    print("Sequence based workflow")

# is this a project based xml?

if xml_type == "":
    bins = None
    elements = None
    dialog2 ={}
    try:
        main_project = root.find("./project")
        logger.info("Main project: ", main_project)
    except:
        main_project = None
        print("Is not a project")
    if main_project is not None:
        elements = find_project_elements()
    else:
        elements = False

    if not elements:
        print("No Sequences or Clips found in project")
    else:
        sel_list = projects_selection_list(elements)  # create formated list of elements

    # ------------------------------------------------------DIALOG XML PROJECT ELEMENT SELECTION----------------------------------------------

        dialog2 = comp.AskUser("List of elements",
                               {1: {1: "element", 2: "Dropdown", "Name": "Select element:", "Options": sel_list},
                                2: {1: "Note", 2: "Text", "Readonly": True, "Lines": 2, "Name": "",
                                    "Default": "* Sequence"}})
        if dialog2 is None:
            print("XML element selection canceled, script execution aborted")
            exit_message("XML element selection canceled\n- script execution stopped")
        else:
            main_element, xml_type = projects_selection_list(elements, int(dialog2["element"]))  # get selected element and element type from elements list


# ----------------------------------------------READ CLIPITEMS FROM SEQUENCE -------------------------------------
# _______________________________________________________________________________________________________________________

if xml_type == "seq":
    # prepare sequence data
    try:
        xml["length"] = int(main_element.find("./duration").text)
    except:
        xml["length"] = 0
        print("Sequence length not found")
    try:
        xml["fps"] = int(main_element.find("./rate/timebase").text)
    except:
        xml["fps"] = 0
        print("Sequence timebase not found")
    try:
        xml["name"] = main_element.find("./name").text
    except:
        print("Sequence name not found")
        xml["name"] = "undefined"
    try:
        xml["width"] = int(main_element.find("./media/video/format/samplecharacteristics/width").text)
        xml["height"] = int(main_element.find("./media/video/format/samplecharacteristics/height").text)
    except:
        xml["width"] = 0
        xml["height"] = 0
        print("Sequence dimensions not found")

    # prepare file based data from sequence
    save_file_links()
    parse_sequence(main_element)
    if len(subseq_list) > 0:  # todo for future use
        print("We have ", len(subseq_list), "subsequences.")

    # length of sequence provided in xml file is sometimes not correct for us
    xml["length"] = get_max_out(xml["length"])

# ------------------------------------------BIN TYPE------------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------------
elif xml_type == "bin":
    if main_element =="- Main":
        xml["name"] = "- Main"
    else:
        try:
            xml["name"] = main_element.find("./name").text
            print("Bin name: ", xml["name"])
        except:
            print("Bin name not found.")
            xml["name"] = "undefined"
    save_file_links()
    if parse_bin(main_element):
        rewrite_bin_points()
    else:
        print("No clipitems found in this element. Script execution aborted.")
        exit_message("No clipitems found in this element\n- script execution stopped")

else:
    print("No bin, no sequence. Script execution aborted.")
    exit_message("No elements found in xml file\n- script execution stopped")

#----------------------------------------------FILE AVAILABILITY CHECK -------------------------------------
#___________________________________________________________________________________________________________

clean_clipitem_names()#replace name values with unique and cleaned names

# initial check if files are available at their original locations
def_d_dir = " "
def_d_ext = ""
off_list = []
on_list = []

# find initial number of missing files, create list of them, update clipitems
logger.info("--- file availability check ---")
for val in list(saved_file_par.values()):  # iterate all known files from xml
    logger.info (val)
    if "Clip" in val and str(val['Clip']) != "{}":
        # we check if this file is needed in our context
        for clipitem in all_parsed_clipitems:
            if par_value(clipitem, "Clip") == str(val['Clip']):
                path = str(val['Clip'])
                logger.info("path from saved_file_par:", path)
                if dialog['do_relink'] == 0 and is_loadable(path):  # if user selected no relink we check if files are
                                                                   # available and if can be loaded
                    if os.path.isfile(path):
                        """

                        if eyeon.fileexists(path):
                            update_clipitems('Clip',path, 'Online', True)
                            on_list.append(path)
                        else:
                            update_clipitems('Clip', path, 'Online', False)
                            off_list.append(path)
                            print("File found, but not readable by Fusion. Non-ASCII characters in path or filename?")
                            """
                        update_clipitems('Clip', path, 'Online', True)
                        on_list.append(path)
                    else:
                        update_clipitems('Clip', path, 'Online', False)
                        off_list.append(path)
                else:  # if user selected relink for all clips, clips remain flagged as offline and are added to the list of missing files
                    off_list.append(path)
                break  # we want no duplicates in list

"""-------------------------------------------------------RELINK DIALOG ----------------------------------------------------
____________________________________________________________________________________________________________________________
"""
df = {}
list_limit = 10  # max size missing file dialog box
while len(off_list) > 0:
    displayed_files = create_path_list(off_list)
    if len(off_list) < list_limit:
        numb_displayed = len(off_list) + 1
    else:
        numb_displayed = list_limit
    df[1] = {1: "Message:", 2: "Text", "Name": "Offline or unsupported media files: " + str(len(off_list)), "ReadOnly": True,
             "Lines": numb_displayed, "Wrap": False, "Default": displayed_files}
    df[2] = {1: "Dir", 2: "PathBrowse", "Name": "Directory containing missing files:", "Default": def_d_dir,
             "Required": True}
    df[3] = {1: "Subdirs", 2: "Checkbox", "Name": "Search in subdirectories", "Default": 0}
    df[4] = {1: "Extension", 2: "Text", "Name": "File extension replacement (optional, e.g. dng):", "ReadOnly": False,
             "Lines": 1, "Wrap": False, "Default": def_d_ext}
    df[5] = {1: "Help:", 2: "Text", "Name": "Note: ", "ReadOnly": True, "Lines": 2, "Wrap": True,
             "Default": "If you cancel this dialog, offline clips will be replaced with placeholder nodes."}
    dialog_f = comp.AskUser("XML Importer - Relink files (Cancel to skip)", df)
    if dialog_f is None:
        print("Relink dialog canceled")
        break
    else:
        if dialog_f['Dir'] != '':
            def_d_dir = dialog_f['Dir']
            # searching in selected directory only
            for val in list(saved_file_par.values()):
                if "Clip" in val and str(val['Clip']) != "{}":
                    # we check if this file is needed in our context
                    for clipitem in all_parsed_clipitems:
                        if par_value(clipitem, "Clip") == str(val['Clip']):
                            path = str(val['Clip'])  # old path
                            if dialog_f['Subdirs'] == 0:
                                if dialog_f['Extension'] == '':
                                    newpath = dialog_f['Dir'] + (os.path.split(path))[1]
                                else:
                                    newpath = dialog_f['Dir'] + (os.path.splitext((os.path.split(path))[1]))[0] + "." + \
                                              dialog_f['Extension']
                                    def_d_ext = dialog_f['Extension']
                                if os.path.isfile(newpath):
                                    update_clipitems('Clip', path, 'Online', True)
                                    update_clipitems('Clip', path, 'Clip', newpath)
                                    off_list.remove(path)
                                    on_list.append(newpath)
                                logger.info(newpath)

            # searching in subdirectories
            if dialog_f['Subdirs'] == 1:
                for root, dirs, files in os.walk(dialog_f['Dir']):
                    if len(off_list) > 0:
                        for fname in files:
                            logger.info (fname)
                            for val in off_list:
                                path = val  # old path
                                newname = (os.path.split(path))[1]
                                if dialog_f['Extension'] != '':
                                    newname = (os.path.splitext(newname))[0] + "." + dialog_f['Extension']
                                    def_d_ext = dialog_f['Extension']
                                if fname == newname:
                                    logger.info("old path ", path, " replaced with ", os.path.join(root, fname))
                                    if os.path.isfile(os.path.join(root, newname)):
                                        update_clipitems('Clip', path, 'Online', True)
                                        update_clipitems('Clip', path, 'Clip', os.path.join(root, fname))
                                        if path in off_list:
                                            off_list.remove(path)
                                        else:
                                            logger.info("Path no more in the list?: ", path)
                                        on_list.append(os.path.join(root, fname))
                                    else:
                                        print("File is not readable for Fusion. Non-ascii characters in path?")
                                    break
                    else:
                        print("All files relinked")
                        break
        else:
            print("No directory selected for relink")

"""----------------------------------------------FLOW CREATION DIALOG -----------------------------------------------------
___________________________________________________________________________________________________________________________
"""
dialog3 = {}
mess_stat = ""
if xml_type == "seq":
    mess_stat = 'Imported sequence name: "' + xml["name"] + '"\n   Number of clipitems: ' + str(
        len(all_parsed_clipitems)) + "\n   Number of online files: " + str(len(on_list)) + "\n   " \
        "Number of offline files: " + str(len(off_list)) + "\n   Number of tracks: " + \
                str(len(clipitems_counter[0]))
    dialog3[7] = {1: "flow_type", 2: "Dropdown", "Name": "Flow type:", "Options": ["Connected Sequence"], "Default": 0}
    if xml["length"] > 0:
        dialog3[2] = {1: "set_length", 2: "Checkbox",
                      "Name": "Set composition duration to " + str(xml["length"]) + " frames", "Default": 1}
        mess_stat = mess_stat + "\n   Duration: " + str(xml["length"]) + " frames"
    if xml["width"] != 0 and xml["height"] != 0:
        dialog3[3] = {1: "set_fsize", 2: "Checkbox",
                      "Name": "Set composition dimensions to " + str(xml["width"]) + "x" + str(
                          xml["height"]) + " pixels", "Default": 1}
        mess_stat = mess_stat + "\n   Dimensions: " + str(xml["width"]) + "x" + str(xml["height"]) + " pixels"
    if xml["fps"] != 0:
        dialog3[5] = {1: "set_fps", 2: "Checkbox", "Name": "Set composition timebase to " + str(xml["fps"]) + " fps",
                      "Default": 1}
        mess_stat = mess_stat + "\n   Timebase: " + str(xml["fps"]) + " fps"

elif xml_type == "bin":
    mess_stat = 'Imported bin name: "' + xml["name"] + '"\n   Number of clips: ' + str(
        len(all_parsed_clipitems)) + "\n   Number of online files: " + str(len(on_list)) + "\n   " \
        "Number of offline files: " + str(len(off_list)) + "\n"
    dialog3[7] = {1: "flow_type", 2: "Dropdown", "Name": "Flow type:", "Options": ["2d Flow"], "Default": 0}
    dialog3[10] = {1: "clear_points", 2: "Checkbox", "Name": "Ignore in/out points on clips", "Default": 0}
dialog3[1] = {1: "Message:", 2: "Text", "Name": "", "ReadOnly": True, "Lines": 10, "Wrap": True, "Default": mess_stat}
dialog3[8] = {1: "add_space", 2: "Slider", "Name": "Add additonal space for custom tools:", "Min": 0, "Max": 10,
              "Integer": True, "Default": 1}
dialog3[9] = {1: "saver_creation", 2: "Multibutton", "Name": "Create savers:",
              "Options": ["No", "Yes"], "Default": 1}
dialog3[11] = {1: "create_timecode", 2: "Checkbox", "Name": "Process TC with MetadataTC Fuse", "Default" : 1}
dialog3_s = comp.AskUser("XML Importer - Flow creation", dialog3)
if dialog3_s is None:
    print("Creation dialog canceled.")
    exit_message("Flow creation canceled\n- script execution stopped")

# if selected in dialog, clear in and out points in bin based clipitems
ret = False
try:
    if dialog3_s["clear_points"] == 1:
        ret = rewrite_bin_points(True)
except:
    pass
if ret:
    print("Cleared in and out points on all clips in bin")

"""------------------------------------------------SAVER AND NEW XML DIALOG -----------------------------------------------------------------
_________________________________________________________________________________________________________________________________________________
"""
if dialog3_s["saver_creation"] == 1:
    dialog4 = {}
    dialog4_s = None
    dir_selected = 0  # flag - 1 if directory is selected and writable, 0 if not
    msg1 = "Select directory for output files:\n"
    default = OrderedDict((("create_cl_saver", 1), ("create_seq_saver", 1),
                           ("create_track_saver", 0),  ("saver_maindir", "q:\\temp\\"),
                           ("create_subdir", 1), ("saver_format", 9)))
    while dir_selected == 0:
        if not dialog4_s is None:
            for key in list(default.keys()):
                default[key] = dialog4_s[key]
        dialog4[4] = {1: "create_cl_saver", 2: "Dropdown", "Name": "Add Savers for:",
                      "Options": ["no clips", "all clips", "all video files", "online video files"],
                      "Default": default["create_cl_saver"]}
        if xml_type == "seq":
            dialog4[7] = {1: "create_seq_saver", 2: "Checkbox", "Name": "Add Saver at the end of sequence",
                        "Default": default["create_seq_saver"]}
            dialog4[8] = {1: "create_track_saver", 2: "Checkbox", "Name": "Add Saver at the end of track(s)",
                          "Default": default["create_track_saver"]}
        dialog4[1] = {1: "saver_maindir", 2: "PathBrowse", "Name": msg1, "Required": True,
                      "Default": default["saver_maindir"]}
        dialog4[2] = {1: "create_subdir", 2: "Checkbox", "Name": "Create subdirectory '" + xml["name" ] + "'",
                      "Default": default["create_subdir"]}
        dialog4[0] = {1: "saver_format", 2: "Dropdown", "Name": "Savers format",
                      "Options": list(saver_formats.keys()), "Default": default["saver_format"]}

        dialog4_s = comp.AskUser("XML Importer - Saver creation", dialog4)
        if dialog4_s is None:
            dialog3_s[
                "saver_creation"] = 0  # if user canceled this dialog, no savers are created an we set the value of previous dialog to 0
            print("Saver dialog canceled.")
            break
        else:
            if dialog4_s["saver_maindir"] != " ":
                if os.access(dialog4_s["saver_maindir"], os.W_OK):
                    dir_selected = 1
                else:
                    msg1 = "Selected directory is not writable."
                    continue

            else:
                msg1 = "Saver directory is not selected. Please select or Cancel"
else:
    print("Saver creation was not selected, skipping saver creation dialog")

"""------------------------------------------------SET GLOBAL CREATION SETTINGS -----------------------------------------------------------------
_________________________________________________________________________________________________________________________________________________
"""
# set global composition settings
if "set_length" in dialog3_s and dialog3_s["set_length"] == 1:
    gl_start = comp.GetAttrs("COMPN_GlobalStart")
    comp.SetAttrs({"COMPN_GlobalEnd": gl_start + xml["length"]})
    prj["length"] =  xml["length"]
else:
    prj["length"] = comp.GetAttrs("COMPN_GlobalEnd") - comp.GetAttrs("COMPN_GlobalStart")
    logger.info(prj["length"])
if "set_fsize" in dialog3_s and dialog3_s["set_fsize"] == 1:
    comp.SetPrefs({"Comp.FrameFormat.Width": xml["width"], "Comp.FrameFormat.Height": xml["height"]})
    prj["width"] = xml["width"]
    prj["height"] = xml["height"]
else:
    prj["width"] = comp.GetPrefs("Comp.FrameFormat.Width")
    prj["height"] = comp.GetPrefs("Comp.FrameFormat.Height")
    logger.info(prj["width"], "x", prj["height"])
if "set_fps" in dialog3_s and dialog3_s["set_fps"] == 1:
    comp.SetPrefs({"Comp.FrameFormat.Rate": xml["fps"]})
    prj["fps"] =  xml["fps"]
else:
    prj["fps"] = comp.GetPrefs("Comp.FrameFormat.Rate")
    logger.info(prj["fps"])
# setting for bin workflow
if "fps" not in xml:
    xml["fps"] = prj["fps"]

# ---------------------------------------------------FLOW TYPE "CONNECTED SEQUENCE/2D FLOW"-----------------------------------------------
# _________________________________________________________________________________________________________________________________

if dialog3_s["flow_type"] == 0:
    comp.Lock()
    comp.StartUndo("XML Import " + xml["name"])
    # create background node based on global settings
    if xml_type == "seq":
        background_glob = comp.AddTool("Background")
        background_glob.Width = prj["width"]
        background_glob.Height = prj["height"]
        last_bg_output = background_glob.output
    comp.AutoPos = False
    first_XPos = comp.XPos
    first_YPos = comp.YPos
    # create flow
    create_flow(all_parsed_clipitems)
    create_saver_node(None, "seq")
    comp.Unlock()
    comp.EndUndo(True)
    exit_message("Import completed\n- end of script")