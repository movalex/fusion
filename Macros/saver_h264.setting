{
	Tools = ordered() {
		Saver_H264 = Saver {
			CtrlWZoom = false,
			Inputs = {
				ProcessWhenBlendIs00 = Input { Value = 0, },
				Clip = Input {
					Value = Clip {
						Length = 0,
						Saving = true,
						TrimIn = 0,
						ExtendFirst = 0,
						ExtendLast = 0,
						Loop = 1,
						AspectMode = 0,
						Depth = 0,
						GlobalStart = -2000000000,
						GlobalEnd = 0
					},
				},
				CreateDir = Input { Value = 1, },
				OutputFormat = Input { Value = FuID { "OpenEXRFormat" }, },
				["Gamut.SLogVersion"] = Input { Value = FuID { "SLog2" }, },
				StartEndRenderScripts = Input { Value = 1, },
				StartRenderScript = Input { Value = "print('[Rendering Started]')\n", },
				EndRenderScript = Input { Value = "print('[FFMPEG Encoding Intool Script]')\n\nfusion = fu or Fusion()\n\n-- -------------------------------------------------------\n-- Specify how audio is handled\n-- -------------------------------------------------------\n-- Should ffmpeg trim the Movie to the shortest clip duration of the audio or the video track?\naudioTrimtoShortestClip = 1\n-- audioTrimtoShortestClip = 0\n\n-- Where is the audio track coming from in the Comp:\n\n-- Don't use any audio\n-- audioFilename = ' '\n-- Don't have any audio offset\n-- audioOffset = ' '\n\n-- Use the current Saver node based audio file\naudioFilename = self.SoundFilename[0].Value\n-- Use the current Saver node based audio offset (measured in frames)\naudioOffset = self.SoundOffset\n\n-- or \n\n-- Use the Fusion timeline based audio file\n-- audioFilename = comp:GetAttrs().COMPS_AudioFilename\n-- Use the Fusion timeline based audio offset (measured in frames)\n-- audioOffset = comp:GetAttrs().COMPN_AudioOffset\n\n-- -------------------------------------------------------\n-- Specify where the ffmpeg command line tool is installed\n-- -------------------------------------------------------\n\n-- Find out the current operating system platform. The platform local variable should be set to either \"Windows\", \"Mac\", or \"Linux\".\nosPlatform = ' '\nffmpegProgramPath = ' '\n-- Check if the OS is Windows by searching for the Program Files folder\nif string.find(fusion:MapPath('Fusion:/'), 'Program Files', 1) then\n  osPlatform = 'Windows'\n\nffmpegProgramPath = 'C:\\\\ffmpeg\\\\bin\\\\ffmpeg'\n-- Check if the OS is Windows by searching for the Program Files folder\nelseif string.find(fusion:MapPath('Fusion:/'), 'PROGRA~1', 1) then\n  osPlatform = 'Windows'\n\nffmpegProgramPath = 'C:\\\\ffmpeg\\\\bin\\\\ffmpeg'\n-- Check if the OS is Mac by searching for the Applications folder\nelseif string.find(fusion:MapPath('Fusion:/'), 'Applications', 1) then\n  osPlatform = 'Mac'\n  ffmpegProgramPath = '/usr/local/bin/ffmpeg'\n\nelse\n  osPlatform = 'Linux'\n  ffmpegProgramPath = '/usr/bin/ffmpeg'\nend\n\nprint('[OS] ' .. osPlatform)\nprint('[FFMPEG Path] ' .. ffmpegProgramPath)\n\n-- -------------------------------------------------------\n-- Helper functions copied from the scriptlib.lua file\n-- -------------------------------------------------------\n\nfunction parseFilename(filename)\nprint('parsing filename...')\nlocal seq = {}\nseq.FullPath = filename\n\nprint('full path ' .. seq.FullPath)\n\nstring.gsub(seq.FullPath, \"^(.+[/\\\\])(.+)\", \nfunction(path, name)\n    seq.Path = path\n    print('folder path: ' .. seq.Path)\n    seq.FullName = name\n    print('file name: ' .. seq.FullName)\nend)\n\nstring.gsub(seq.FullName, \"^(.+)(%..+)$\", \nfunction(name, ext)\n    seq.Name = name\n    print('name: ' .. seq.Name)\n    seq.Extension = ext\n    print('extension: ' .. seq.Extension)\nend)\n\nif not seq.Name then -- no extension?\nseq.Name = seq.FullName\nend\n\nseq.SNum = string.match(seq.Name, \"%d+$\")\n\nif seq.SNum then \n    seq.Number = tonumber( seq.SNum ) \n    seq.Padding = string.len( seq.SNum )\n    seq.CleanName = string.match(seq.Name,\"^(.-)%d+$\" )\nelse\n    seq.SNum = \"0000\"\n    seq.Number = 0\n    seq.Padding = 4\n    seq.CleanName = seq.Name\nend\n\nprint('Start number: ' .. seq.SNum)    \nprint('Clean Name: ' .. seq.CleanName)\n\nif seq.Extension == nil then \nseq.Extension = \"\"\nend\n\nreturn seq\nend\n\n-- -------------------------------------------------------\n-- Figure out the comp Audio clip\n-- -------------------------------------------------------\n\nffmpegAudioPrefixCommands = ' '\nffmpegAudioPostfixCommands = ' '\nif audioFilename == nil then\n  print('[FFMPEG Audio Filename] No Audio Track Active')\nelse\n  if string.len(audioFilename) > 3 then\n    -- print('[FFMPEG Audio Filename] ' .. audioFilename)\n    print('[FFMPEG Audio Filename] ' .. cmp:MapPath(audioFilename))\n    if audioOffset == nil then\n      print('[FFMPEG Audio Offset] No Time Offset')\n    else\n      print('[FFMPEG Audio Offset] ' .. audioOffset)\n    end\n  \n    -- Build the audio track commands\n    --ffmpegAudioPrefixCommands = '-i \"' .. audioFilename .. '\"'\n    ffmpegAudioPrefixCommands = '-i \"' .. cmp:MapPath(audioFilename) .. '\"'\n  \n    -- Trim the Movie to the shortest clip duration of the audio or the video track\n    if audioTrimtoShortestClip == 1 then\n      print('[FFMPEG Trim Clip to Shortest Duration] Active')\n      ffmpegAudioPostfixCommands = ' ' .. '-shortest' .. ' '\n    end\n  else\n    -- Error: The audio filename is less then three characters long\n    print('[FFMPEG Audio Filename] No Audio Track Active')\n  end\nend\n-- -------------------------------------------------------\n-- Figure out the Saver node filenames\n-- -------------------------------------------------------\n\n-- seq = parseFilename(self.Clip.Filename)\nsaverfile = self.Clip.Filename\nprint('Parsing Saver file... ' .. saverfile)\nseq = parseFilename(fu:MapPath(self.Clip.Filename))\n\n\n-- Debug the sequence table\n-- dump(seq)\n\n-- Example: filename.%04d.exr\nffmpegImageSequenceFilename = seq.Path .. seq.CleanName .. '%0' .. seq.Padding .. \"d\" .. seq.Extension\nprint('[FFMPEG Start Frame] ' .. comp.RenderStart)\nprint('[FFMPEG Formatted Image Sequence] ' .. ffmpegImageSequenceFilename)\n\n-- Example: filename.mp4\nffmpegMovieFilename = seq.Path .. seq.CleanName .. '.mp4'\nprint('[FFMPEG Exported Movie] ' .. ffmpegMovieFilename)\n\n-- Example: filename.txt\nffmpegLogFilename = seq.Path .. seq.CleanName .. '.txt'\nprint('[FFMPEG Logfile] ' .. ffmpegLogFilename)\n\n-- A gamma 1 to 2.2 adjustment should be applied for exr output\n-- Note: Your copy of FFMPEG has to support the \"-apply_trc\" option or you will get an \"Unrecognized option 'apply_trc'.\" error message in the log file.\n\nffmpegApplyGammaCorrection = ' '\n-- if seq.Extension == '.exr' then\n--     print('[FFMPEG EXR Gammma 1.0 to 2.2 Transform Active] [Image Format]' .. seq.Extension)\n--     -- Convert a linear exr to REC 709\n--     -- ffmpegApplyGammaCorrection = '-apply_trc bt709'\n--     -- or\n--     --- Convert a linear exr file to sRGB\n--     ffmpegApplyGammaCorrection = '-apply_trc iec61966_2_1'\n-- end\n\n-- Set the frame rate for the encoded movie\nframeRate = comp:GetPrefs(\"Comp.FrameFormat.Rate\")\nif frameRate == nil then\n\n    frameRate = 24\n\nend\n\nprint('[FFMPEG Frame Rate] ' .. frameRate)\n\n-- -------------------------------------------------------\n-- Encode the image sequence into a movie using ffmpeg\n-- -------------------------------------------------------\n\ncommand = ffmpegProgramPath .. ' ' .. ffmpegAudioPrefixCommands .. ' ' .. ffmpegApplyGammaCorrection .. ' -framerate ' .. frameRate .. ' -f image2 -start_number ' .. comp.RenderStart .. ' -i \"' .. ffmpegImageSequenceFilename .. '\" -r ' .. frameRate .. ' -y -vf \"scale=trunc(iw/2)*1:trunc(ih/2)*1\" -f mp4 -vcodec libx264 -crf 20 -pix_fmt yuv420p -acodec aac ' .. ffmpegAudioPostfixCommands .. ' -strict -2  \"' .. ffmpegMovieFilename .. '\" >> \"' .. ffmpegLogFilename .. '\" 2>&1'\nprint('[Launch Command] ' .. command)\nos.execute(command)\n\nprint('[Done]')\n", },
				FrameSavedScript = Input { Value = "-- Print a status entry in the console every 5 frames\nif time % 5 == 0 then\n	print('.')\nend\n", },
			},
			ViewInfo = OperatorInfo { Pos = { -1055.99, 142.953 } },
		}
	},
	ActiveTool = "Saver_H264"
}