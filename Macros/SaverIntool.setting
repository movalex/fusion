{
	Tools = ordered() {
		SaverIntool = Saver {
			CtrlWZoom = false,
			NameSet = true,
			CustomData = {
				Settings = {
				}
			},
			Inputs = {
				ProcessWhenBlendIs00 = Input { Value = 0, },
				Clip = Input {
					Value = Clip {
						Length = 0,
						Saving = true,
						TrimIn = 0,
						ExtendFirst = 0,
						ExtendLast = 0,
						Loop = 1,
						AspectMode = 0,
						Depth = 0,
						TimeCode = 0,
						GlobalStart = -2000000000,
						GlobalEnd = 0
					},
				},
				CreateDir = Input { Value = 1, },
				OutputFormat = Input { Value = FuID { "OpenEXRFormat" }, },
				["Gamut.SLogVersion"] = Input { Value = FuID { "SLog2" }, },
				StartEndRenderScripts = Input { Value = 1, },
				StartRenderScript = Input { Value = "print('[Rendering Started]')\n", },
				EndRenderScript = Input { Value = "-- FFMPEG Encoding Intool End Render Script v0.3\n-- 2017-07-21 7.08 AM\n-- ---------------------------------------------------------------------------\n-- By Andrew Hazelden <andrew@andrewhazelden.com>\n-- This Fusion Intool script is used to FFMPEG encode your saver node rendered \n-- image sequences into MP4 H.264 movies with a gamma 1.0 to 2.2 conversion applied.\n-- ---------------------------------------------------------------------------\n\n-- Step 1. Install ffmpeg. \n\n-- Windows ffmpeg Download URL: https://ffmpeg.org/download.html\n\n-- MacOS Homebrew Based Install:\n-- brew install ffmpeg\n\n-- CentOS Install:\n-- sudo yum -y install ffmpeg\n\n-- Ubuntu Install:\n-- sudo add-apt-repository ppa:mc3man/trusty-media\n-- sudo apt-get update\n-- sudo apt-get dist-upgrade\n-- sudo apt-get -y install ffmpeg \n\n-- Step 2. Paste the FFMPEG Encoding Intool Script into your Saver node's \"End Render Script\" text field.\n\n-- Step 3. Change the script's \"ffmpegProgramPath\" variable to point to the absolute filepath of the installed copy of ffmpeg.\n-- (On Mac/Linux you can find the active ffmpeg path out using: \"which ffmpeg\")\n\n-- Step 4. Render a short test sequence in Fusion. You should have a new .mp4 movie and a log .txt file saved in the same folder as your rendered image sequence. If you have a saver node based Sound Filename entered it will be added automatically as an audio track to the encoded movie file.\n\n-- ---------------------------------------------------------------------------\n-- Script Notes\n-- ---------------------------------------------------------------------------\n\n-- You can edit the \"audioFilename\" variable to choose if you want the Saver node's audio track included in the movie or if you want to use the Fusion timeline based audio clip.\n\n-- ffmpeg might truncate the frame size using the EXR window data if the background image area is transparent.\n\n-- Fusion 8.2.1 on Linux doesn't process the `cmp = fusion:GetCurrentComp()` command so a fallback mode of \"cmp = fusion\" option will be used. This means comp specific PathMaps are ignored on Fu 8 on Linux and only Global setting based PathMaps work.\n\n-- ---------------------------------------------------------------------------\n-- Version History\n-- ---------------------------------------------------------------------------\n\n-- Initial release\n-- 2017-07-15\n\n-- v0.1 - 2017-07-15 6.30 PM \n-- The intool script now supports working with Saver Nodes that have PathMaps active in the Filename textfield.\n\n-- If a Saver node has a filename entered in the Audio tab > Sound Filename textfield then that audio clip will be added automatically to the ffmpeg encoded movie.\n\n-- v0.2 - 2017-07-16 8.35 AM\n-- Error logging improved\n\n-- v0.3 - 2017-07-21 7.08 AM\n-- Added frame rate detection\n\n-- ---------------------------------------------------------------------------\n-- Todos:\n-- ---------------------------------------------------------------------------\n-- Todo: Support the audio track offset command\n\n-- ---------------------------------------------------------------------------\n\nprint('[FFMPEG Encoding Intool Script]')\n\n-- -------------------------------------------------------\n-- Add the \"Fusion\" object to an intool script\n-- -------------------------------------------------------\n-- Note: The Function fusion:MapPath() is only available in an intool script after we run the eyeon.scriptapp() function.\n\n-- VFXPedia Tip Section:\n-- https://www.steakunderwater.com/VFXPedia/96.0.243.189/index90a9.html?title=Eyeon:Script/Reference/Applications/Fusion_Expressions/Introduction#Accessing_the_Fusion_object_in_InTool_scripts\n\nfusion = eyeon.scriptapp('Fusion', 'localhost')\ncmp = fusion:GetCurrentComp()\nif cmp == nil then\n  -- Fusion 8.2.1 on Linux doesn't process the `cmp = fusion:GetCurrentComp()` command so a fallback mode of \"cmp = fusion\" will be used. This means comp specific PathMaps are ignored on Fu 8 on Linux and only Global setting based PathMaps work.\n  print('[Fusion] Switching Comp: to Fusion: to Handle an Intool Script Scope Error')\n  cmp = fusion\nend\n\n-- -------------------------------------------------------\n-- Specify how audio is handled\n-- -------------------------------------------------------\n\n-- Should ffmpeg trim the Movie to the shortest clip duration of the audio or the video track?\naudioTrimtoShortestClip = 1\n-- audioTrimtoShortestClip = 0\n\n-- Where is the audio track coming from in the Comp:\n\n-- Don't use any audio\n-- audioFilename = ' '\n-- Don't have any audio offset\n-- audioOffset = ' '\n\n-- Use the current Saver node based audio file\naudioFilename = self.SoundFilename[0].Value\n-- Use the current Saver node based audio offset (measured in frames)\naudioOffset = self.SoundOffset\n\n-- or \n\n-- Use the Fusion timeline based audio file\n-- audioFilename = comp:GetAttrs().COMPS_AudioFilename\n-- Use the Fusion timeline based audio offset (measured in frames)\n-- audioOffset = comp:GetAttrs().COMPN_AudioOffset\n\n-- -------------------------------------------------------\n-- Specify where the ffmpeg command line tool is installed\n-- -------------------------------------------------------\n\n-- Find out the current operating system platform. The platform local variable should be set to either \"Windows\", \"Mac\", or \"Linux\".\nosPlatform = ' '\nffmpegProgramPath = ' '\nif string.find(fusion:MapPath('Fusion:/'), 'Program Files', 1) then\n  -- Check if the OS is Windows by searching for the Program Files folder\n  osPlatform = 'Windows'\n  \n  ffmpegProgramPath = 'C:\\\\ffmpeg\\\\bin\\\\ffmpeg'\nelseif string.find(fusion:MapPath('Fusion:/'), 'PROGRA~1', 1) then\n  -- Check if the OS is Windows by searching for the Program Files folder\n  osPlatform = 'Windows'\n  \n  ffmpegProgramPath = 'C:\\\\ffmpeg\\\\bin\\\\ffmpeg'\nelseif string.find(fusion:MapPath('Fusion:/'), 'Applications', 1) then\n  -- Check if the OS is Mac by searching for the Applications folder\n  osPlatform = 'Mac'\n  \n  ffmpegProgramPath = '/usr/local/bin/ffmpeg'\n  -- ffmpegProgramPath = '/Applications/ffmpeg/bin/ffmpeg'\n  -- ffmpegProgramPath = '/Applications/KartaVR/mac_tools/ffmpeg/bin/ffmpeg'\nelse\n  osPlatform = 'Linux'\n\n  ffmpegProgramPath = '/usr/bin/ffmpeg'\n  -- ffmpegProgramPath = '/opt/local/bin/ffmpeg'\nend\n\nprint('[OS] ' .. osPlatform)\nprint('[FFMPEG Path] ' .. ffmpegProgramPath)\n\n-- -------------------------------------------------------\n-- Helper functions copied from the scriptlib.lua file\n-- -------------------------------------------------------\n\nfunction parseFilename(filename)\n  local seq = {}\n  seq.FullPath = filename\n  string.gsub(seq.FullPath, \"^(.+[/\\\\])(.+)\", function(path, name) seq.Path = path seq.FullName = name end)\n  string.gsub(seq.FullName, \"^(.+)(%..+)$\", function(name, ext) seq.Name = name seq.Extension = ext end)\n\n  if not seq.Name then -- no extension?\n    seq.Name = seq.FullName\n  end\n\n  string.gsub(seq.Name, \"^(.-)(%d+)$\", function(name, SNum) seq.CleanName = name seq.SNum = SNum end)\n\n  if seq.SNum then \n    seq.Number = tonumber( seq.SNum ) \n    seq.Padding = string.len( seq.SNum )\n  else\n     seq.SNum = \"\"\n    seq.CleanName = seq.Name\n  end\n\n  if seq.Extension == nil then seq.Extension = \"\" end\n  seq.UNC = ( string.sub(seq.Path, 1, 2) == [[\\\\]] )\n\n  return seq\nend\n\n-- -------------------------------------------------------\n-- Figure out the comp Audio clip\n-- -------------------------------------------------------\n\nffmpegAudioPrefixCommands = ' '\nffmpegAudioPostfixCommands = ' '\nif audioFilename == nil then\n  print('[FFMPEG Audio Filename] No Audio Track Active')\nelse\n  if string.len(audioFilename) > 3 then\n    -- print('[FFMPEG Audio Filename] ' .. audioFilename)\n    print('[FFMPEG Audio Filename] ' .. cmp:MapPath(audioFilename))\n    if audioOffset == nil then\n      print('[FFMPEG Audio Offset] No Time Offset')\n    else\n      print('[FFMPEG Audio Offset] ' .. audioOffset)\n    end\n  \n    -- Build the audio track commands\n    --ffmpegAudioPrefixCommands = '-i \"' .. audioFilename .. '\"'\n    ffmpegAudioPrefixCommands = '-i \"' .. cmp:MapPath(audioFilename) .. '\"'\n  \n    -- Trim the Movie to the shortest clip duration of the audio or the video track\n    if audioTrimtoShortestClip == 1 then\n      print('[FFMPEG Trim Clip to Shortest Duration] Active')\n      ffmpegAudioPostfixCommands = ' ' .. '-shortest' .. ' '\n    end\n  else\n    -- Error: The audio filename is less then three characters long\n    print('[FFMPEG Audio Filename] No Audio Track Active')\n  end\nend\n\n-- -------------------------------------------------------\n-- Figure out the Saver node filenames\n-- -------------------------------------------------------\n\n-- seq = parseFilename(self.Clip.Filename)\nseq = parseFilename(cmp:MapPath(self.Clip.Filename))\n\n-- Debug the sequence table\n-- dump(seq)\n\n-- Example: filename.%04d.exr\nffmpegImageSequenceFilename = seq.Path .. seq.CleanName .. '%0' .. seq.Padding .. \"d\" .. seq.Extension\nprint('[FFMPEG Start Frame] ' .. comp.RenderStart)\nprint('[FFMPEG Formatted Image Sequence] ' .. ffmpegImageSequenceFilename)\n\n-- Example: filename.mp4\nffmpegMovieFilename = seq.Path .. seq.CleanName .. 'mp4'\nprint('[FFMPEG Exported Movie] ' .. ffmpegMovieFilename)\n\n-- Example: filename.txt\nffmpegLogFilename = seq.Path .. seq.CleanName .. 'txt'\nprint('[FFMPEG Logfile] ' .. ffmpegLogFilename)\n\n\n-- A gamma 1 to 2.2 adjustment should be applied for exr output\n-- Note: Your copy of FFMPEG has to support the \"-apply_trc\" option or you will get an \"Unrecognized option 'apply_trc'.\" error message in the log file.\nffmpegApplyGammaCorrection = ' '\nif seq.Extension == '.exr' then\n print('[FFMPEG EXR Gammma 1.0 to 2.2 Transform Active] [Image Format]' .. seq.Extension)\n \n -- Convert a linear exr to REC 709\n -- ffmpegApplyGammaCorrection = '-apply_trc bt709'\n \n -- or\n  \n --- Convert a linear exr file to sRGB\n ffmpegApplyGammaCorrection = '-apply_trc iec61966_2_1'\nend\n\n-- Set the frame rate for the encoded movie\nframeRate = comp:GetPrefs(\"Comp.FrameFormat.Rate\")\nif frameRate == nil then\n  frameRate = 24\nend\nprint('[FFMPEG Frame Rate] ' .. frameRate)\n \n-- -------------------------------------------------------\n-- Encode the image sequence into a movie using ffmpeg\n-- -------------------------------------------------------\ncommand = ffmpegProgramPath .. ' ' .. ffmpegAudioPrefixCommands .. ' ' .. ffmpegApplyGammaCorrection .. ' -framerate ' .. frameRate .. ' -f image2 -start_number ' .. comp.RenderStart .. ' -i \"' .. ffmpegImageSequenceFilename .. '\" -r ' .. frameRate .. ' -y -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" -f mp4 -vcodec libx264 -pix_fmt yuv420p -acodec aac ' .. ffmpegAudioPostfixCommands .. ' -strict -2  \"' .. ffmpegMovieFilename .. '\" >> \"' .. ffmpegLogFilename .. '\" 2>&1'\nprint('[Launch Command] ' .. command)\nos.execute(command)\n\nprint('[Done]')\n", },
				FrameSavedScript = Input { Value = "-- Print a status entry in the console every 5 frames\nif time % 5 == 0 then\n	print('.')\nend\n", }
			},
			ViewInfo = OperatorInfo { Pos = { 221.75, 77.75 } },
		}
	},
	ActiveTool = "SaverIntool"
}